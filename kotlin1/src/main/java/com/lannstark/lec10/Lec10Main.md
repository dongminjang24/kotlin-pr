## 코틀린에서 상속을 다루는 방법

### 1) 추상 클래스
- extend 키워드를 사용하지 않고, ":" 을 사용한다.
- 무조건 상위 클래스의 생성자를 바로 호출해야 합니다.
- override를 필수적으로 붙여줘야 한다.
- 추상 프로퍼티가 아니라면, 상속 받을때 open을 꼭 붙여야 한다.
- 추상클래스에서 자동으로 만들어진 getter를 override(새로정의하기 위해서)
- Java, Kotlin의 모두 추상 클래스는 인스턴스화 활 수 없다!

### 2) 인터페이스
- Java,Kotlin 모두 인터페이스를 인스턴스화 할 수 없습니다!
- Kotlin에서는 backing field가 없는 프로퍼티를 Interface에 만들 수 있다.

### 3) 클래스를 상속할 때 주의할 점
- 상위 클래스를 설계할 때 생성자 또는 초기화 블록에 사용되는 프로퍼티에는 open을 피해야한다.

- 추상 멤버가 아니면 기본적으로 오버라이드가 불가능하다.
  - open을 사용해주어야 한다.

- 상위 클래스의 생성자 또는 초기화 블록에서 open 프로퍼티를 사용하면 얘기치 못한 버그가 생길 수 있다. 


### 4) 자바와 코틀린을 함께 사용할 때 주의할 점
- Internal은 바이트 코드 상 public이 됩니다. 그렇기 때문에 자바 코드에서는 코틀린 모듈의 internal 코드를 가져올 수 있다.
- 코틀린의 protecteddhk 자바의 protected는 다르다. 자바는 같은 패키지의 코틀린 protected 멤버에 접근할 수 있다. 

### 결론
- 코틀린에서 패키지는 namespace 관리용이기 때문에 protected는 의미가 달라졌다.
- 코틀리에서는 default가 사라지고, 모듈간의 접근을 통제하는 internal이 새로 생겼다.
- 생성자에 접근 지시어를 붙일대는 constructor를 명시적으로 써줘야 한다.
- 유틸성 함수를 만들때는 파일 최상단을 이용하면 편리하다.
- 프로퍼티의 custom setter에 접근지시어를 따로 붙일 수 있다.
